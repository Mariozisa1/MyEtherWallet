<template>
  <div class="mew-component--swap">
    <div v-if="isAvailable">
      <app-wallet-block title="Swap">
        <div v-if="!isLoading && fromTokenType">
          <!-- =============================================================== -->
          <!-- You Give -->
          <!-- =============================================================== -->
          <swap-token-selector-interface
            title="YOU GIVE"
            :left-text="maxMsg"
            :max-button="setMaxAmount"
            :token-select="setFromToken"
            :right-text="fiatBalanceFrom"
            :error="amountErrorMessage"
            selected
            :token="fromTokenType"
            :tokens="actualFromTokens"
            :search-tokens="fromTokens"
            placeholder="Enter amount"
            :loading="isLoading || maxLoading"
            :value="tokenInValue"
            :input="val => triggerSetTokenInValue(val, false)"
            popup-title="Select token to swap"
          />
          <div class="d-flex align-center justify-center py-2">
            <v-icon color="textDark" size="30px">mdi-swap-vertical</v-icon>
          </div>
          <!-- =============================================================== -->
          <!-- You Receive -->
          <!-- =============================================================== -->
          <swap-network-selector
            :selected-network="selectedNetwork"
            :networks="supportedNetworks"
            class="mb-2"
            @selectedNetwork="setSwapSelectedNetwork"
          />
          <swap-token-selector-interface
            title="YOU RECEIVE"
            :token-select="setToToken"
            :token="toTokenType"
            :tokens="actualToTokens"
            :search-tokens="toTokens"
            btn-text="Select Token"
            :value="tokenOutValue || 0"
            :loading="isLoading"
            read-only
          />
          <div class="mt-8">
            <v-row v-if="showToAddress">
              <v-col>
                <span>Where should we send your crypto?</span>
              </v-col>
            </v-row>
            <v-row v-if="showToAddress">
              <v-col class="pb-0">
                <module-address-book
                  ref="toAddressInput"
                  class="ToAddressInput"
                  :is-valid-address-func="isValidToAddress"
                  :label="toAddressLabel"
                  @setAddress="setToAddress"
                />
              </v-col>
            </v-row>
          </div>
        </div>
        <swap-loader v-else />
        <!--
            =====================================================================================
             Providers List
            =====================================================================================
            -->
        <div v-if="hasMinEth">
          <v-slide-y-transition v-if="showAnimation" hide-on-leave group>
            <swap-provider-mentions
              key="showAnimation"
              :is-loading="isLoadingProviders"
              :check-loading="checkLoading"
              @showProviders="showProviders"
            />
          </v-slide-y-transition>
          <div v-else key="showAnimation1">
            <swap-providers-list
              :step="step"
              :available-quotes="availableQuotes"
              :set-provider="setProvider"
              :to-token-symbol="toTokenType ? toTokenType.symbol : ''"
              :to-token-icon="toTokenType ? toTokenType.img : ''"
              :is-loading="isLoadingProviders"
              :providers-error="providersErrorMsg"
              :class="isFromNonChain ? '' : 'mt-7'"
              :selected-provider-id="selectedProviderId"
            />
            <!--
                  =====================================================================================
                  Swap Fee
                  =====================================================================================
                -->
            <swap-fee
              v-if="showNetworkFee"
              :is-from-chain="!isFromNonChain"
              :show-fee="showSwapFee"
              :getting-fee="loadingFee"
              :error="feeError"
              :total-cost="totalCost"
              :tx-fee="txFee"
              :total-gas-limit="totalGasLimit"
              :not-enough-eth="notEnoughEth"
              :from-eth="isFromTokenMain"
              is-swap
              @onLocalGasPrice="handleLocalGasPrice"
            />
          </div>
          <!--
          =====================================================================================
            User Message Block: store your Bitcoin on Ethereum
          =====================================================================================
          -->
          <app-user-msg-block
            v-if="
              toTokenType &&
              toTokenType.value &&
              toTokenType.value.toLowerCase() == 'bitcoin' &&
              isEthNetwork
            "
            class="mt-sm-5"
            :message="msg.storeBitcoin"
          >
            <div class="border-top mt-3">
              <v-expansion-panels
                flat
                class="expansion-panels--remove-paddings"
              >
                <v-expansion-panel>
                  <v-expansion-panel-header
                    color="greyLight"
                    class="textLight--text"
                  >
                    How can I get wrapped Bitcoin?
                  </v-expansion-panel-header>
                  <v-expansion-panel-content color="greyLight" class="pa-0">
                    <div class="textLight--text mb-2">
                      When you swap to Bitcoin, it is moved to the Bitcoin
                      blockchain, & requires a Bitcoin wallet. In order to keep
                      Bitcoin in MyEtherWallet, you can swap to wrapped Bitcoin
                      instead. Wrapped Bitcoin is an Ethereum token, with a
                      value approximately equal to 1 BTC. Wrapped Bitcoins can
                      be stored in MEW, and can be used as any other Ethereum
                      asset: you can swap it to other tokens, use it as
                      collateral in DeFi apps, etc. There are multiple kinds of
                      wrapped Bitcoins, but they roughly do the same thing.
                      <a
                        :href="getArticle('mv-btc-to-eth-mew-swap')"
                        target="_blank"
                      >
                        Learn more about Wrapped Bitcoin.
                      </a>
                    </div>
                    <v-row class="mt-6">
                      <v-col cols="12" md="4">
                        <mew-button
                          btn-size="small"
                          btn-style="outline"
                          title="Swap to renBTC"
                          :has-full-width="true"
                          @click.native="swapTo('renBTC')"
                        />
                      </v-col>
                      <v-col cols="12" md="4">
                        <mew-button
                          btn-size="small"
                          btn-style="outline"
                          title="Swap to wBTC"
                          :has-full-width="true"
                          @click.native="swapTo('wBTC')"
                        />
                      </v-col>
                      <v-col cols="12" md="4">
                        <mew-button
                          btn-size="small"
                          btn-style="outline"
                          title="Swap to PBTC"
                          :has-full-width="true"
                          @click.native="swapTo('PBTC')"
                        />
                      </v-col>
                    </v-row>
                  </v-expansion-panel-content>
                </v-expansion-panel>
              </v-expansion-panels>
            </div>
          </app-user-msg-block>
          <mew-button
            v-if="hasMinEth"
            title="Proceed"
            :has-full-width="true"
            :disabled="disableNext"
            btn-size="xlarge"
            class="NextButton mt-7"
            @click.native="showConfirm()"
          />
        </div>
        <app-user-msg-block
          v-if="!hasMinEth"
          class="mt-sm-5"
          color="#eef3fd"
          disable-icon
          :message="msg.lowBalance"
        >
          <div class="mt-3 mx-n1">
            <mew-button
              btn-size="large"
              class="ma-1 font-weight-bold"
              color-theme="#4B83E8"
              has-full-width
              @click.native="openBuySell"
            >
              <v-icon class="pr-1"> mdi-credit-card-outline </v-icon>
              Buy more {{ network.type.currencyName }}
            </mew-button>
            <div class="d-flex justify-center">
              <div class="blue--text mt-3 mb-3 pointer" @click="openQr">
                <v-icon class="pr-1" color="blue">
                  mdi-arrow-collapse-down
                </v-icon>
                <span>
                  Receive {{ network.type.currencyName }} from a different
                  account
                </span>
              </div>
            </div>
          </div>
        </app-user-msg-block>
      </app-wallet-block>
    </div>
    <!--
          =====================================================================================
           Message is SWAP NOT Available
          =====================================================================================
    -->
    <template v-else>
      <div class="swap-not-available">
        <app-user-msg-block :message="swapNotAvailableMes" />
      </div>
    </template>
  </div>
</template>

<script>
import { toBN, fromWei, toWei, isAddress } from 'web3-utils';
import {
  debounce,
  isEmpty,
  clone,
  isUndefined,
  isObject,
  isNumber
} from 'lodash';
import { mapGetters, mapState, mapActions } from 'vuex';
import xss from 'xss';
import MultiCoinValidator from 'multicoin-address-validator';
import BigNumber from 'bignumber.js';

import Notification, {
  NOTIFICATION_TYPES,
  NOTIFICATION_STATUS
} from '@/modules/notifications/handlers/handlerNotification';
import NonChainNotification from '@/modules/notifications/handlers/nonChainNotification';
import { Toast, ERROR, SUCCESS } from '@/modules/toast/handler/handlerToast';
import { MAIN_TOKEN_ADDRESS } from '@/core/helpers/common';
import handlerAnalytics from '@/modules/analytics-opt-in/handlers/handlerAnalytics.mixin';
import buyMore from '@/core/mixins/buyMore.mixin.js';
import Swapper from './handlers/handlerSwap';
import handleError from '../confirmation/handlers/errorHandler';
import { EventBus } from '@/core/plugins/eventBus';
import { fromBase, toBase } from '@/core/helpers/unit';

const MIN_GAS_LIMIT = 800000;
let localContractToToken = {};
export default {
  name: 'ModuleSwap',
  components: {
    SwapLoader: () => import('@/modules/swap/components/SwapLoader'),
    SwapTokenSelectorInterface: () =>
      import('./components/SwapTokenSelectorInterface'),
    SwapNetworkSelector: () => import('./components/SwapNetworkSelector'),
    AppBorderContainer: () => import('@/core/components/AppBorderContainer'),
    AppWalletBlock: () => import('@/core/components/AppWalletBlock'),
    AppButtonBalance: () => import('@/core/components/AppButtonBalance'),
    AppUserMsgBlock: () => import('@/core/components/AppUserMsgBlock'),
    ModuleAddressBook: () => import('@/modules/address-book/ModuleAddressBook'),
    SwapProvidersList: () => import('./components/SwapProvidersList.vue'),
    SwapProviderMentions: () => import('./components/SwapProviderMentions.vue'),
    AppTransactionFee: () => import('@/core/components/AppTransactionFee.vue'),
    SwapFee: () => import('./components/SwapFee.vue')
  },
  mixins: [handlerAnalytics, buyMore],
  props: {
    fromToken: {
      type: String,
      default: MAIN_TOKEN_ADDRESS
    },
    amount: {
      type: String,
      default: '0'
    },
    isAvailable: {
      type: Boolean,
      default: true
    }
  },
  data() {
    const supportedNetworks = Swapper.helpers.getSupportedNetworks();
    return {
      step: 0,
      selectedNetwork: supportedNetworks[1],
      supportedNetworks: supportedNetworks.filter(item => {
        if (item.id) return item;
      }),
      confirmInfo: {
        to: '',
        from: '',
        fromImg: '',
        toImg: '',
        fromType: '',
        toType: '',
        validUntil: 0,
        selectedProvider: '',
        txFee: ''
      },
      swapper: null,
      toTokenType: {},
      fromTokenType: {},
      tokenInValue: this.amount || '0',
      tokenOutValue: '0',
      availableTokens: { toTokens: [], fromTokens: [], featured: [] },
      availableQuotes: [],
      currentTrade: null,
      allTrades: [],
      isLoading: true,
      loadingFee: false,
      feeError: '',
      defaults: {
        fromToken: this.fromToken
      },
      isLoadingProviders: false,
      showAnimation: false,
      checkLoading: true,
      addressValue: {},
      selectedProvider: {},
      refundAddress: '',
      localGasPrice: '0',
      mainTokenDetails: {},
      cachedAmount: '0',
      selectedProviderId: undefined,
      abortSetTokenValue: false,
      clearingSwap: false,
      maxLoading: false
    };
  },
  computed: {
    ...mapState('swap', ['prefetched', 'swapTokens']),
    ...mapState('wallet', ['web3', 'address', 'balance', 'identifier']),
    ...mapState('global', ['gasPriceType']),
    ...mapGetters('global', [
      'network',
      'isEthNetwork',
      'gasPriceByType',
      'getFiatValue'
    ]),
    ...mapGetters('wallet', [
      'balanceInETH',
      'tokensList',
      'initialLoad',
      'balanceInWei'
    ]),
    ...mapGetters('external', [
      'balanceFiatValue',
      'contractToToken',
      'getCoinGeckoTokenById'
    ]),
    ...mapGetters('article', ['getArticle']),
    swapNotAvailableMes() {
      return {
        title: `Swap is not available on this network`,
        subtitle:
          'Please select ETH, BNB or MATIC networks to use this feature.'
      };
    },
    /**
     * @returns a boolean
     * based on how the swap state is
     */
    showNetworkFee() {
      return this.showNextButton && !this.isFromNonChain;
    },
    /**
     * @returns a boolean
     * based on how the swap state is
     */
    showNextButton() {
      return (
        this.step > 0 &&
        this.providersErrorMsg.subtitle === '' &&
        !this.isLoadingProviders
      );
    },
    maxMsg() {
      return `Max: ${new BigNumber(this.maxAmount).toFixed(6)}`;
    },
    maxAmount() {
      const max = new BigNumber(this.availableBalance).minus(
        fromWei(toBN(this.localGasPrice).muln(MIN_GAS_LIMIT))
      );
      return this.isFromTokenMain
        ? max.gt(0)
          ? max.toFixed()
          : '0'
        : this.availableBalance.toFixed();
    },
    /**
     *Returns errors messages based on network
     */
    errorMsgs() {
      return {
        amountEthIsTooLow: `You do not have enough ${this.network.type.currencyName} to swap.`,
        amountExceedsEthBalance: `Amount exceeds your ${this.network.type.currencyName} balance.`,
        amountExceedsTxFee: `Amount entered doesn't allow for transaction fee`,
        amountLessThan0: 'Swap amount must be greater than 0',
        doNotOwnToken: 'You do not own this token'
      };
    },
    /**
     * Property returns correct mes
     */
    msg() {
      return {
        lowBalance: {
          title: `Your ${this.network.type.currencyName} balance is too low`,
          subtitle: `Every transaction requires a small amount of ${this.network.type.currencyName} to execute. Even if you have tokens to swap, when your ${this.network.type.currencyName} balance is close to zero, you won't be able to send anything until you fund your account.`
        },
        storeBitcoin: {
          title: `Did you know? You can store your Bitcoin on ${this.network.type.name_long}`,
          subtitle: `To swap to BTC you need a Bitcoin wallet, but you can swap to wrapped Bitcoin instead and store it in your ${this.network.type.name_long} wallet.`
        }
      };
    },
    disableNext() {
      const disableSet =
        this.step < 2 ||
        this.amountErrorMessage !== '' ||
        this.feeError !== '' ||
        !this.hasSelectedProvider ||
        this.providersErrorMsg.subtitle !== '' ||
        this.loadingFee ||
        this.showAnimation;
      if (this.fromTokenType?.isEth) {
        return disableSet;
      }
      return (
        disableSet || (!this.refundAddress && this.actualTrade?.length === 0)
      );
    },
    providersErrorMsg() {
      let msg = '';
      let subError = '';
      if (!this.isLoading) {
        if (
          new BigNumber(this.tokenInValue).lt(this.selectedProvider.minFrom)
        ) {
          msg = 'The minimum requirement for this provider is';
          subError = `${this.selectedProvider.minFrom} ${this.fromTokenType?.symbol}`;
        } else if (
          new BigNumber(this.tokenInValue).gt(this.selectedProvider.maxFrom)
        ) {
          msg = 'The maximum requirement for this provider is';
          subError = `${this.selectedProvider.maxFrom} ${this.fromTokenType?.symbol}`;
        } else if (this.availableQuotes.length === 0) {
          msg =
            'No providers found for this token pair. Select a different token pair or try again later.';
        } else if (
          this.selectedProvider.rate === '0' ||
          this.feeError === 'Invalid Input'
        ) {
          msg =
            'Provided input is invalid or provider is having issues. Please try again!';
        }
      }
      return {
        subtitle: msg,
        subtitleError: subError
      };
    },
    /**
     * Checks whether selected from token is
     * the network's currency
     */
    isFromTokenMain() {
      if (this.isLoading) return false;
      return this.fromTokenType?.contract === MAIN_TOKEN_ADDRESS;
    },
    /**
     * Check if fromTokenType is a native token
     * from other chains
     */
    isFromNonChain() {
      if (this.isLoading || this.fromTokenType?.contract === undefined)
        return false;
      return this.fromTokenType?.hasOwnProperty('isEth')
        ? !this.fromTokenType?.isEth
        : !isAddress(this.fromTokenType?.contract);
    },
    /**
     * @returns object of all the token data
     * to swap to
     */
    actualToTokens() {
      if (this.isLoading) return [];
      let validToTokens =
        this.network.type.name === this.selectedNetwork.id
          ? this.toTokens.filter(item => {
              if (
                item.contract.toLowerCase() !==
                this.fromTokenType?.contract?.toLowerCase()
              )
                return item;
            })
          : this.toTokens;
      validToTokens = this.formatTokenPrice(validToTokens);
      let filteredTrendingTokens = this.trendingTokens().filter(token => {
        return token.contract !== this.fromTokenType?.contract;
      });
      filteredTrendingTokens = this.formatTokenPrice(filteredTrendingTokens);
      let returnableTokens = [];
      if (filteredTrendingTokens.length) {
        returnableTokens = returnableTokens.concat([
          {
            header: 'Trending'
          },
          ...filteredTrendingTokens
        ]);
      }
      returnableTokens = returnableTokens.concat([
        {
          header: 'All'
        },
        ...validToTokens
      ]);
      return returnableTokens;
    },
    /**
     * @returns object of all the tokens
     * to swap to
     */
    toTokens() {
      if (this.isLoading) return [];
      return this.availableTokens.toTokens.reduce((arr, token) => {
        if (token && localContractToToken[token.contract])
          arr.push(localContractToToken[token.contract]);
        return arr;
      }, []);
    },
    /**
     * @returns object of all token data
     * to swap from
     */
    actualFromTokens() {
      if (this.isLoading) return [];
      let validFromTokens = this.fromTokens.filter(
        item =>
          item.contract.toLowerCase() !==
          this.toTokenType?.contract?.toLowerCase()
      );
      let tradebleWalletTokens = this.tokensList.filter(item => {
        for (const vt of validFromTokens) {
          if (vt.contract.toLowerCase() === item?.contract?.toLowerCase())
            return item;
        }
      });
      for (const token of tradebleWalletTokens) {
        validFromTokens = validFromTokens.filter(item => {
          if (token?.contract?.toLowerCase() !== item.contract.toLowerCase()) {
            return item;
          }
        });
      }
      tradebleWalletTokens = this.formatTokensForSelect(tradebleWalletTokens);
      const returnableTokens = [
        {
          header: 'My Wallet'
        },
        ...tradebleWalletTokens
      ];
      return returnableTokens;
    },
    /**
     * @returns object of other tokens
     * to swap from
     */
    fromTokens() {
      return this.availableTokens.fromTokens.reduce((arr, token) => {
        if (token && localContractToToken[token.contract])
          arr.push(localContractToToken[token.contract]);
        return arr;
      }, []);
    },
    txFee() {
      return toBN(this.totalGasLimit).mul(toBN(this.localGasPrice)).toString();
    },
    totalCost() {
      const amount = this.isFromTokenMain ? this.tokenInValue : '0';
      const amountWei = toWei(amount);
      return BigNumber(this.txFee).plus(amountWei).toString();
    },
    totalGasLimit() {
      if (this.currentTrade) {
        let totalGas = toBN(0);
        this.currentTrade.transactions?.forEach(tx => {
          totalGas = totalGas.add(toBN(tx.gas));
        });
        return totalGas.toString();
      }
      return '0';
    },
    /**
     * check whether the to token is in ETH chain or not
     * also checks if the userAddress is not empty
     *
     * @returns {String} - Ethereum Address
     */
    toAddress() {
      if (this.selectedNetwork.type !== 'evm') {
        if (!isEmpty(this.addressValue)) {
          return this.addressValue.isValid
            ? this.addressValue.value
            : this.address;
        }
        return this.address;
      }

      if (this.toTokenType?.contract === MAIN_TOKEN_ADDRESS) {
        return this.address;
      }
      if (this.selectedNetwork.type === 'evm') return this.address;
      return this.address;
    },
    /**
     * Checks whether or not the user has a minimum eth balance to swap:
     * @returns{boolean}
     */
    hasMinEth() {
      if (!isEmpty(this.fromTokenType)) {
        return true;
      }
      return toBN(this.balanceInWei).gte(
        toBN(this.localGasPrice).muln(MIN_GAS_LIMIT)
      );
    },

    /**
     * Checks whether the user has enough
     * balance for the transaction
     */
    notEnoughEth() {
      try {
        const balanceAfterFees = toBN(this.balance).sub(toBN(this.totalCost));
        return balanceAfterFees.isNeg();
      } catch (e) {
        return true;
      }
    },
    showToAddress() {
      return this.selectedNetwork.type !== 'evm';
    },
    /**
     * @returns BigNumber of the available balance for the From Token
     */
    availableBalance() {
      if (!this.initialLoad && this.fromTokenType?.name) {
        const hasBalance = this.tokensList.find(
          token =>
            token.contract.toLowerCase() ===
            this.fromTokenType.contract.toLowerCase()
        );
        const tokenBalance =
          !isEmpty(hasBalance) &&
          !isEmpty(hasBalance.balance) &&
          hasBalance.hasOwnProperty('decimals')
            ? this.getTokenBalance(hasBalance.balance, hasBalance.decimals)
            : new BigNumber(0);
        return this.isFromTokenMain
          ? this.getTokenBalance(this.balanceInWei, 18)
          : tokenBalance;
      }
      return new BigNumber(0);
    },
    availableBalanceTo() {
      return `Balance: ${this.getAvailableBalance().balance}`;
    },
    fiatBalanceFrom() {
      const x = new BigNumber(this.fromTokenType.usdBalance).times(
        new BigNumber(this.maxAmount)
      );
      const balance = x.div(new BigNumber(this.fromTokenType.tokenBalance));
      return `≈ ${this.getFiatValue(balance)}`;
    },
    fiatBalanceTo() {
      return `≈ ${this.getAvailableBalance().fiat}`;
    },
    /**
     * Determines whether or not to show swap fee panel
     * Fee is shown if provider was selected and no errors are passed
     */
    showSwapFee() {
      return this.step >= 2 && this.availableBalance.gt(0);
    },
    /**
     * Method validates input for the From token amount against user input
     * Used to show error messages for the amount input component
     */
    amountErrorMessage() {
      if (!this.initialLoad && !this.isLoading && this.fromTokenType?.name) {
        /* Balance is <= 0*/
        if (this.availableBalance.lte(0)) {
          return this.isFromTokenMain
            ? this.errorMsgs.amountEthIsTooLow
            : this.tokensList.length > 0 &&
              !this.isFromTokenMain &&
              !this.isFromNonChain
            ? this.errorMsgs.doNotOwnToken
            : new BigNumber(this.tokenInValue).lt(0)
            ? this.errorMsgs.amountLessThan0
            : '';
        }
        if (
          !Swapper.helpers.hasValidDecimals(
            this.tokenInValue,
            this.fromTokenType.decimals
          )
        ) {
          return `Provided amount exceeds valid decimal.`;
        }
        /*Eth Balance is too low to send a transaction*/
        if (!this.hasMinEth) {
          return this.errorMsgs.amountEthIsTooLow;
        }
        if (this.tokenInValue && this.tokenInValue !== '') {
          /* Amount entered < 0 */
          if (new BigNumber(this.tokenInValue).lt(0)) {
            return this.errorMsgs.amountLessThan0;
          }
          /* ETH only: Amount entered > (ETH Balance - Gas Price )*/
          if (
            this.isFromTokenMain &&
            this.availableBalance.lt(new BigNumber(this.tokenInValue))
          ) {
            return this.errorMsgs.amountExceedsEthBalance;
          }
          /*ERC20 Only: Amount entered > Balance  */
          if (
            !this.isFromTokenMain &&
            this.availableBalance.lt(new BigNumber(this.tokenInValue))
          ) {
            return `Amount exceeds your ${this.fromTokenType.symbol} balance.`;
          }
          /* Changelly Errors: */

          if (
            new BigNumber(this.tokenInValue).lt(this.selectedProvider.minFrom)
          ) {
            return `Amount below ${this.selectedProvider.minFrom} ${this.fromTokenType.symbol} min`;
          }
          if (
            new BigNumber(this.tokenInValue).gt(this.selectedProvider.maxFrom)
          ) {
            return `Amount over ${this.selectedProvider.maxFrom} ${this.fromTokenType.symbol} max`;
          }
        }
      }
      return '';
    },
    /**
     * Checks whether or not there is a selected provider
     * @returns{boolean}
     */
    hasSelectedProvider() {
      return !isEmpty(this.selectedProvider);
    },
    toAddressLabel() {
      const name =
        !isEmpty(this.toTokenType) && this.toTokenType.hasOwnProperty('name')
          ? this.toTokenType.name
          : 'ETH';
      return `To ${name} address`;
    },
    multipleWatcher() {
      return this.network, this.web3, this.tokensList;
    }
  },
  watch: {
    selectedNetwork: {
      handler: function (val) {
        this.isLoading = true;
        this.swapper
          .getAllTokens(val.id)
          .then(tokens => {
            this.processTokens(tokens);
          })
          .then(() => {
            this.isLoading = false;
          });
      },
      deep: true
    },
    multipleWatcher: {
      handler: function () {
        this.resetSwapState();
      }
    },
    tokenInValue() {
      this.feeError = '';
      if (!this.clearingSwap) {
        this.trackSwap('tokenFromValueChanged');
      }
    },
    gasPriceType() {
      if (this.currentTrade) this.currentTrade.gasPrice = this.localGasPrice;
    },
    txFee: {
      handler: function () {
        this.checkFeeBalance();
      },
      immediate: true
    },
    selectedProvider(p, oldVal) {
      if (!isEmpty(oldVal) && !this.clearingSwap) {
        this.trackSwap('switchProviders');
      }
      if (isEmpty(p)) this.selectedProviderId = undefined;
    },
    selectedProviderId(newVal) {
      if (isNumber(newVal) && !this.clearingSwap) {
        this.trackSwap(
          `swapProvider: ${newVal + 1}/${this.availableQuotes.length}`
        );
      }
    },
    defaults: {
      handler: function () {
        this.setDefaults();
      },
      deep: true,
      immediate: true
    },
    amountErrorMessage(newVal) {
      if (newVal !== '') this.availableQuotes.splice(0);
    },
    '$route.query': {
      handler: function () {
        this.setTokenFromURL();
      }
    },
    fromTokenType: {
      handler: function (newVal) {
        this.fromTokenType = newVal;
      },
      deep: true,
      immediate: false
    },
    toTokenType: {
      handler: function (newVal) {
        this.toTokenType = newVal?.header ? undefined : newVal;
      },
      deep: true,
      immediate: false
    }
  },
  beforeDestroy() {
    this.abortSetTokenValue = true;
  },
  beforeMount() {
    this.setTokenFromURL();
  },
  mounted() {
    this.abortSetTokenValue = false;
    this.trackSwap('swapPageView');
    this.resetSwapState();
  },
  methods: {
    ...mapActions('notifications', ['addNotification']),
    ...mapActions('swap', ['setSwapTokens']),
    resetSwapState() {
      this.mainTokenDetails = this.contractToToken(MAIN_TOKEN_ADDRESS);
      localContractToToken = {};
      localContractToToken[MAIN_TOKEN_ADDRESS] = this.mainTokenDetails;
      this.setupSwap();
    },
    setSwapSelectedNetwork(network) {
      this.selectedNetwork = network;
    },
    /**
     * @returns all trending tokens
     * to swap to
     */
    trendingTokens() {
      if (this.isLoading) return [];
      return this.availableTokens.featured.reduce((arr, token) => {
        if (token && localContractToToken[token.contract])
          arr.push(localContractToToken[token.contract]);
        return arr;
      }, []);
    },
    setupTokenInfo(tokens) {
      tokens.forEach(token => {
        token.pricef = this.getFiatValue(token.price);
        token.value = token.address;
        token.contract = token.address;
        token.subtext = token.name;
        token.img = `https://img.mewapi.io/?image=${token.logoURI}`;
        this.setToLocaContractToToken(Object.assign({}, token));
      });
    },
    /**
     * Add token to localContractToToken
     */
    setToLocaContractToToken(token) {
      if (token.name === '' || token.symbol === '' || token.subtext === '') {
        return;
      }

      localContractToToken[token.contract] = token;
    },
    /**
     * Handles emitted values from module-address-book
     */
    setToAddress(value, isValid) {
      this.addressValue = {
        value,
        isValid
      };
      this.setTokenInValue(this.tokenInValue);
    },
    swapTo(to) {
      const findToken = this.availableTokens.toTokens.find(
        item => item.symbol.toLowerCase() === to.toLowerCase()
      );
      if (!this.clearingSwap) {
        this.trackSwap('stayOnEth: ' + to);
      }
      this.toTokenType = findToken;
    },
    setupSwap() {
      if (this.isAvailable) {
        this.isLoading = !this.prefetched;
        this.swapper = new Swapper(this.web3, this.network.type.name);
        if (!this.prefetched) {
          this.swapper
            .getAllTokens(this.selectedNetwork.id)
            .then(tokens => {
              this.processTokens(tokens);
            })
            .then(() => {
              this.isLoading = false;
            });
        } else {
          this.processTokens(this.swapTokens, false);
          this.isLoading = false;
        }

        this.localGasPrice = this.gasPriceByType(this.gasPriceType);
      }
    },
    // reset values after executing transaction
    clear() {
      this.clearingSwap = true;
      this.step = 0;
      this.confirmInfo = {
        to: '',
        from: '',
        fromImg: '',
        toImg: '',
        fromType: '',
        toType: '',
        validUntil: 0,
        selectedProvider: '',
        txFee: '',
        actualTrade: {}
      };

      this.swapper = null;
      this.toTokenType = {};
      this.fromTokenType = this.getDefaultFromToken();
      this.tokenInValue = '0';
      this.tokenOutValue = '0';
      this.availableTokens = { toTokens: [], fromTokens: [] };
      this.availableQuotes = [];
      this.currentTrade = null;
      this.allTrades = [];
      this.isLoading = false;
      this.loadingFee = false;
      this.feeError = '';
      this.selectedProviderId = undefined;
      this.defaults = {
        fromToken: this.fromToken
      };
      this.isLoadingProviders = false;
      this.checkLoading = true;
      this.addressValue = {};
      this.selectedProvider = {};
      this.localGasPrice = '0';
      if (this.$refs.amountInput) this.$refs.amountInput.clear();
      this.refundAddress = '';
      this.maxLoading = false;
      this.setupSwap();
    },
    formatTokensForSelect(tokens) {
      if (!Array.isArray(tokens)) return [];
      return tokens.map(t => {
        t.totalBalance = t.hasOwnProperty('usdBalancef')
          ? this.getFiatValue(t.usdBalancef)
          : this.getFiatValue('0.00');
        t.tokenBalance = t.hasOwnProperty('balancef') ? t.balancef : '0.00';
        t.price = t.hasOwnProperty('pricef')
          ? this.getFiatValue(t.pricef)
          : this.getFiatValue('0.00');
        t.name = t.hasOwnProperty('symbol') ? t.symbol : '';
        return t;
      });
    },
    formatTokenPrice(tokens) {
      if (!Array.isArray(tokens)) return [];
      return tokens.map(t => {
        t.price = t.hasOwnProperty('pricef')
          ? this.getFiatValue(t.pricef)
          : this.getFiatValue('0.00');
        return t;
      });
    },
    resetAddressValues({ clearRefund = true, clearTo = true }) {
      if (clearRefund)
        if (this.$refs.refundAddressInput) {
          this.$refs.refundAddressInput.clear();
        }
      if (clearTo)
        if (this.$refs.toAddressInput) {
          this.$refs.toAddressInput.clear();
        }
      this.selectedProvider = {};
    },
    /**
     * Set the max available amount to swap from
     */
    async setMaxAmount() {
      this.maxLoading = true;
      this.trackSwap('setMaxValue');
      if (
        !isEmpty(this.toTokenType) &&
        this.toTokenType.isEth &&
        this.toTokenType.hasOwnProperty('symbol') &&
        this.isFromTokenMain
      ) {
        const fromAmount = toBase(
          this.availableBalance,
          this.fromTokenType.decimals
        );
        try {
          const quotes = await this.swapper.getAllQuotes({
            fromT: this.fromTokenType,
            toT: this.toTokenType,
            fromAmount: fromAmount,
            fromAddress: this.address
          });
          const highest = quotes.sort(
            (a, b) =>
              BigNumber(b.amount).toNumber() - BigNumber(a.amount).toNumber()
          );
          const swapObj = {
            fromAddress: this.address,
            toAddress: this.toAddress,
            provider: highest[0].provider,
            fromT: this.fromTokenType,
            toT: this.toTokenType,
            quote: highest[0],
            fromAmount: fromAmount
          };

          const trade = await this.swapper.getTrade(swapObj);
          trade['gasPrice'] = this.localGasPrice;
          let parsedGasLimit = BigNumber(0);
          trade.transactions.forEach(tx => {
            parsedGasLimit = parsedGasLimit.plus(tx.gas);
          });
          const tokenInValue = new BigNumber(this.availableBalance)
            .minus(
              fromWei(toBN(this.localGasPrice).muln(parsedGasLimit.toNumber()))
            )
            .toFixed();
          this.setTokenInValue(tokenInValue);
          this.maxLoading = false;
        } catch (e) {
          this.setMaxWithoutEstimate();
        }
        return;
      }
      this.setMaxWithoutEstimate();
    },
    setMaxWithoutEstimate() {
      const gasLimit =
        this.toTokenType && !this.toTokenType.isEth ? 21000 : MIN_GAS_LIMIT;
      const availableBalanceMinusGas = new BigNumber(
        this.availableBalance
      ).minus(fromWei(toBN(this.localGasPrice).muln(gasLimit)));
      this.tokenInValue = this.isFromTokenMain
        ? availableBalanceMinusGas.gt(0)
          ? availableBalanceMinusGas.toFixed()
          : '0'
        : this.availableBalance.toFixed();
      this.setTokenInValue(this.tokenInValue);
      this.maxLoading = false;
    },
    /**
     * Gets the default from token
     */
    getDefaultFromToken() {
      const findToken = this.actualFromTokens.find(item => {
        if (item.contract === this.defaults.fromToken) return item;
      });
      if (
        this.defaults.fromToken === MAIN_TOKEN_ADDRESS &&
        new BigNumber(this.balanceInETH).gt(0)
      ) {
        return findToken;
      }
      return findToken ? findToken : this.actualFromTokens[0];
    },
    getDefaultToToken() {
      const findToken = this.actualToTokens.find(item => {
        if (item.contract === this.defaults.toToken) return item;
      });
      if (
        this.defaults.toToken === MAIN_TOKEN_ADDRESS &&
        new BigNumber(this.balanceInETH).gt(0)
      ) {
        return this.mainTokenDetails;
      }
      return findToken ? findToken : this.actualToTokens[0];
    },
    processTokens(tokens, storeTokens) {
      this.setupTokenInfo(tokens.toTokens);
      this.setupTokenInfo(tokens.featured);
      this.availableTokens = tokens;
      this.setDefaults();
      if (isUndefined(storeTokens)) {
        this.setSwapTokens(tokens);
      }
    },
    setDefaults() {
      setTimeout(() => {
        this.fromTokenType = this.getDefaultFromToken();
        this.toTokenType = this.getDefaultToToken();
        this.setTokenInValue(this.tokenInValue);
        this.clearingSwap = false;
      }, 500);
    },
    setFromToken(value) {
      if (
        value === undefined ||
        (!value?.hasOwnProperty('isEth') &&
          value?.contract?.toLowerCase() !== MAIN_TOKEN_ADDRESS)
      ) {
        const foundToken = this.actualFromTokens.filter(item => {
          if (
            item?.contract &&
            item?.contract?.toLowerCase() === value?.contract?.toLowerCase()
          )
            return item;
        });
        value =
          foundToken.length > 0 ? foundToken[0] : this.actualFromTokens[0];
      }
      this.fromTokenType = value;
      this.resetAddressValues({ clearTo: false });
      this.$nextTick(() => {
        if (value && value.name && !this.clearingSwap) {
          this.trackSwapToken('from: ' + value.name);
        }
        this.setTokenInValue(this.tokenInValue);
      });
    },
    setToToken(value) {
      if (!value?.hasOwnProperty('isEth')) {
        const foundToken = this.actualToTokens.filter(item => {
          if (
            item?.contract &&
            item?.contract?.toLowerCase() === value?.contract?.toLowerCase()
          )
            return item;
        });
        value = foundToken[0];
      }
      this.toTokenType = value;
      this.resetAddressValues({ clearRefund: false });
      if (value && value.name) {
        this.trackSwapToken('to: ' + value.name);
      }
      this.setTokenInValue(this.tokenInValue);
    },
    triggerSetTokenInValue: debounce(function (val) {
      this.setTokenInValue(val);
    }, 500),
    setTokenInValue(value) {
      // Abort set token in value
      if (this.abortSetTokenValue) return;
      /**
       * Ensure that both pairs have been set
       * before calling the providers
       */
      this.belowMinError = false;
      if (this.isLoading || this.initialLoad) return;
      const val = value ? value : 0;
      this.tokenInValue = BigNumber(val).toFixed();
      if (
        !this.isFromNonChain &&
        (this.availableBalance.lt(new BigNumber(this.tokenInValue)) ||
          !this.hasMinEth)
      ) {
        this.step = 0;
        return;
      }
      if (isEmpty(this.fromTokenType)) {
        Toast('From token cannot be empty!', {}, ERROR);
        return;
      }

      if (
        !Swapper.helpers.hasValidDecimals(
          this.tokenInValue,
          this.fromTokenType.decimals
        )
      ) {
        return;
      }
      this.tokenOutValue = '0';

      /**
       * unselect quotes
       */
      this.availableQuotes.forEach(q => {
        if (q) {
          q.isSelected = false;
        }
      });
      /**
       * reset quotes, trades, and step
       */
      this.availableQuotes = [];
      this.allTrades = [];
      this.step = 0;
      if (this.showToAddress && !this.addressValue?.isValid) return;
      if (
        !isEmpty(this.toTokenType) &&
        this.showToAddress &&
        (isEmpty(this.addressValue) ||
          (!isEmpty(this.addressValue) && !this.addressValue.isValid))
      ) {
        return;
      }
      if (
        !BigNumber(value).isNaN() &&
        BigNumber(value).gt(0) &&
        !isEmpty(this.fromTokenType) &&
        !isEmpty(this.toTokenType) &&
        !isEmpty(this.fromTokenType?.symbol) &&
        !isEmpty(this.toTokenType?.symbol)
      ) {
        this.isLoadingProviders = true;
        this.showAnimation = true;
        this.cachedAmount = this.tokenInValue;
        this.swapper
          .getAllQuotes({
            fromT: this.fromTokenType,
            toT: this.toTokenType,
            fromAmount: toBase(this.tokenInValue, this.fromTokenType.decimals),
            fromAddress: this.address
          })
          .then(providers => {
            this.step = 1;
            if (this.tokenInValue === this.cachedAmount) {
              this.selectedProvider = {};
              if (providers.length) {
                this.lastSetToken = providers[0].amount;
                this.availableQuotes = providers.reduce((arr, p) => {
                  if (
                    providers.length === 1 ||
                    BigNumber(p.transactions?.[0]?.value).gt(0)
                  ) {
                    p.amount = p.minimum || p.amount;
                    p.rate = new BigNumber(p.amount)
                      .dividedBy(new BigNumber(this.tokenInValue))
                      .toString();
                    p.isSelected = false;
                    arr.push(p);
                  }
                  return arr;
                }, []);
                this.tokenOutValue = providers[0].amount;

                this.setProvider(0, true);
              }
              this.isLoadingProviders = false;
            } else {
              this.isLoadingProviders = false;
            }
          });
      }
    },
    setProvider(idx, clicked) {
      this.belowMinError = false;
      this.availableQuotes.forEach((q, _idx) => {
        if (_idx === idx) {
          this.selectedProviderId = _idx;
          q.isSelected = true;
          this.tokenOutValue = q.to_amount;
          this.getTrade(idx);
          if (!clicked) {
            this.selectedProvider = q;
            if (!this.clearingSwap) {
              this.trackSwap(
                `swapProvider: ${idx + 1}/ ${this.availableQuotes.length}`
              );
            }
          } else {
            this.selectedProvider =
              q.amount !== this.selectedProvider.amount ? q : {};
          }
        }
      });
    },
    getTrade(idx) {
      if (this.availableQuotes.length === 0) {
        return;
      }

      if (BigNumber(this.availableQuotes[idx].minFrom).gt(this.tokenInValue)) {
        return;
      }

      this.feeError = '';
      if (this.allTrades.length > 0 && this.allTrades[idx])
        return this.setupTrade(this.allTrades[idx]);
      if (!this.allTrades[idx]) {
        this.loadingFee = true;
      }
      const swapObj = {
        fromAddress: this.address,
        toAddress: this.toAddress,
        provider: this.availableQuotes[idx].provider,
        fromT: this.fromTokenType,
        toT: this.toTokenType,
        quote: this.availableQuotes[idx],
        fromAmount: toBase(this.tokenInValue, this.fromTokenType.decimals)
      };
      if (this.isFromNonChain) {
        swapObj['refundAddress'] = this.refundAddress;
      }
      const trade = this.swapper.getTrade(swapObj);
      if (trade instanceof Promise) {
        trade.then(tradeResponse => {
          if (!tradeResponse) {
            const index = this.availableQuotes.indexOf(swapObj.quote);
            if (index > -1) {
              // Remove the quote
              this.availableQuotes.splice(index, 1);
            }
            this.feeError = 'There was an issue with the provider';
            return;
          }
          if (this.tokenInValue === this.cachedAmount) {
            if (
              isObject(tradeResponse) &&
              tradeResponse.hasOwnProperty('provider')
            ) {
              this.allTrades[idx] = tradeResponse;
            }
            this.setupTrade(tradeResponse);
          }
        });
      } else {
        this.setupTrade(this.availableQuotes[this.selectedProviderId]);
      }
    },
    setupTrade(trade) {
      this.loadingFee = false;
      // fixes race case where address gets invalidated when
      // transaction is still loading
      if (this.availableQuotes.length > 0) {
        this.step = 2;
      }
      if (trade instanceof Error || !trade) {
        this.feeError = 'Provider issue';
        return;
      }
      this.feeError = '';
      this.currentTrade = trade;
      this.currentTrade.gasPrice = this.localGasPrice;
      if (!this.isFromNonChain) {
        this.checkFeeBalance();
      }
    },
    showConfirm() {
      this.trackSwap('showConfirm');
      this.setConfirmInfo();
      this.executeTrade();
    },
    setConfirmInfo() {
      const toPrice = this.toTokenType.price ? this.toTokenType.price : 0;
      const fromPrice = this.fromTokenType.price ? this.fromTokenType.price : 0;
      const obj = {
        from: this.address,
        to: this.toAddress,
        fromType: this.fromTokenType.symbol,
        toType: this.toTokenType.symbol,
        fromImg: this.fromTokenType.img,
        toImg: this.toTokenType.img,
        fromVal: this.tokenInValue,
        toVal: this.tokenOutValue,
        toUsdVal: BigNumber(toPrice).times(this.tokenOutValue).toFixed(),
        fromUsdVal: BigNumber(fromPrice).times(this.tokenInValue).toFixed(),
        validUntil: new Date().getTime() + 10 * 60 * 1000,
        selectedProvider: this.selectedProvider,
        txFee: this.txFee,
        gasPriceType: this.gasPriceType,
        actualTrade: this.currentTrade,
        fromTokenType: this.fromTokenType,
        toTokenType: this.toTokenType
      };
      if (this.isFromNonChain) {
        obj['refundAddress'] = this.refundAddress;
      }
      this.confirmInfo = obj;
    },
    isValidToAddress(address) {
      if (this.availableQuotes.length > 0) {
        return this.swapper.isValidToAddress({
          provider: this.availableQuotes[0].provider,
          toT: this.toTokenType,
          address
        });
      }
      if (this.toTokenType.isEth) {
        return MultiCoinValidator.validate(address, 'Ethereum');
      }
      try {
        return MultiCoinValidator.validate(address, this.toTokenType.name);
      } catch (e) {
        return this.swapper.isValidToAddress({
          provider: 'changelly',
          toT: this.toTokenType,
          address
        });
      }
    },
    executeTrade() {
      const currentTradeCopy = clone(this.currentTrade);
      this.swapper
        .executeTrade(this.currentTrade, this.confirmInfo)
        .then(res => {
          this.swapNotificationFormatter(res, currentTradeCopy);
        })
        .catch(err => {
          if (
            err.message ===
            'Batch transaction rejected in between transactions!'
          ) {
            Toast(err && err.message ? err.message : err, {}, ERROR);
            this.clear();
            return;
          }
          if (err && err.statusObj?.hashes?.length > 0) {
            err.statusObj.hashes.forEach(item => {
              const error = handleError(item);
              if (error) Toast(error, {}, ERROR);
            });
            return;
          }
          const error = handleError(err);
          if (error) Toast(err && err.message ? err.message : err, {}, ERROR);
        });
    },
    getTokenBalance(balance, decimals) {
      return new BigNumber(fromBase(balance, decimals));
    },
    swapNotificationFormatter(obj, currentTrade) {
      obj.hashes.forEach((hash, idx) => {
        const main = {
          from: this.address,
          type: NOTIFICATION_TYPES.SWAP,
          network: this.network.type?.name,
          status: NOTIFICATION_STATUS.PENDING,
          fromTxData: {
            currency: this.confirmInfo.fromType,
            amount: this.confirmInfo.fromVal,
            icon: this.confirmInfo.fromImg
          },
          toTxData: {
            currency: this.confirmInfo.toType,
            amount: this.confirmInfo.toVal,
            icon: this.confirmInfo.toImg,
            to: this.confirmInfo.to
          }
        };

        if (this.isFromNonChain) {
          const notif = Object.assign(
            {
              swapObj: obj,
              to: this.toAddress
            },
            main
          );
          this.addNotification(new NonChainNotification(notif)).then(() => {
            const currency = this.toTokenType?.symbol;
            Toast(
              `Swap initiated, you should receive ${currency} in 1-3 hours. You will be notified when it's completed`,
              {},
              SUCCESS
            );
            this.clear();
          });
        } else {
          const notif = Object.assign(
            {
              hash,
              swapObj: obj
            },
            main,
            currentTrade.transactions[idx]
          );
          this.addNotification(new Notification(notif)).then(this.clear);
        }
      });
    },
    getAvailableBalance(from) {
      const token = from ? this.fromTokenType : this.toTokenType;
      if (!this.initialLoad && token?.name) {
        const hasBalance = this.tokensList.find(
          t => t.contract.toLowerCase() === token.contract.toLowerCase()
        );
        const tokenBalance =
          !isEmpty(hasBalance) &&
          !isEmpty(hasBalance.balance) &&
          hasBalance.hasOwnProperty('decimals')
            ? this.getTokenBalance(hasBalance.balance, hasBalance.decimals)
            : new BigNumber(0);
        return {
          balance: tokenBalance,
          fiat:
            this.getFiatValue(hasBalance?.usdBalancef) || this.getFiatValue('0')
        };
      }
      return { balance: new BigNumber(0), fiat: this.getFiatValue('0') };
    },
    checkFeeBalance() {
      this.feeError = '';
      if (this.notEnoughEth) {
        this.feeError = `Not enough ${this.network.type.currencyName} to pay for transaction fee.`;
      }
    },
    setTokenFromURL() {
      if (Object.keys(this.$route.query).length > 0) {
        const { fromToken, toToken, amount } = this.stripQuery(
          this.$route.query
        );
        this.defaults = {
          fromToken,
          toToken
        };
        this.tokenInValue = amount ? `${amount}` : '0';
      }
    },
    stripQuery(queryObj) {
      const newObj = {};
      Object.keys(queryObj).forEach(key => {
        newObj[key] = xss(queryObj[key]);
      });
      return newObj;
    },
    showProviders(val) {
      if (!this.isLoadingProviders && val) {
        this.showAnimation = false;
      }
    },
    handleLocalGasPrice(e) {
      this.localGasPrice = e;
    },
    openQr() {
      EventBus.$emit('openQrCode');
    }
  }
};
</script>

<style lang="scss" scoped>
.input-swap-container {
  box-shadow: 0px 4px 4px rgb(11 40 64 / 4%), 0px 2px 10px rgb(11 40 64 / 6%),
    0px 3px 16px rgb(11 40 64 / 4%);
  border-radius: 10px;
}

.v-input--selection-controls {
  padding: 0;
  margin: 0;
}

.border-top {
  border-top: 1px solid var(--v-greyMedium-base);
}

.swap-not-available {
  @media (min-width: 960px) {
    min-height: 45vh;
  }
}

.read-only {
  pointer-events: none;
}

.input-block-title {
  letter-spacing: 2px;
  font-size: 12px;
}
.pointer {
  cursor: pointer;
}
.cta {
  color: #4b83e8;
}
</style>

<style lang="scss">
.mew-component--swap {
  .swap-input {
    max-width: 300px;
    .v-input__slot {
      padding: 0 !important;
    }
    input {
      font-size: 24px !important;
      text-align: right !important;
    }
  }
}
</style>
